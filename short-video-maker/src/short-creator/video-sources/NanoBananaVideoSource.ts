import { BaseVideoSource, VideoSearchParams, VideoResult } from "./BaseVideoSource";
import { ImageGenerationService } from "../../image-generation/services/ImageGenerationService";
import { OrientationEnum } from "../../types/shorts";
import { VIDEO_DIMENSIONS } from "../utils/Constants";
import { logger } from "../../logger";
import cuid from "cuid";

export interface NanoBananaVideoParams extends VideoSearchParams {
  imageData: {
    prompt: string;
    style: string;
    mood: string;
  };
  videoId?: string;
  sceneIndex?: number;
}

export class NanoBananaVideoSource extends BaseVideoSource {
  constructor(private imageGenerationService: ImageGenerationService) {
    super();
  }

  async findVideo(params: VideoSearchParams): Promise<VideoResult> {
    throw new Error("NanoBananaVideoSource requires NanoBananaVideoParams with imageData");
  }

  async generateStaticVideo(params: NanoBananaVideoParams): Promise<VideoResult> {
    try {
      logger.debug({ 
        prompt: params.imageData.prompt, 
        style: params.imageData.style, 
        mood: params.imageData.mood 
      }, "Generating static video with NANO BANANA");

      // Combine prompt with style and mood
      const enhancedPrompt = `${params.imageData.prompt}. Style: ${params.imageData.style}. Mood: ${params.imageData.mood}`;
      
      // Set aspect ratio based on video orientation
      const aspectRatio = params.orientation === OrientationEnum.portrait ? "9:16" : "16:9";
      
      const result = await this.imageGenerationService.generateImages({
        prompt: enhancedPrompt,
        numberOfImages: 1,
        aspectRatio: aspectRatio
      }, params.videoId, params.sceneIndex);

      if (!result.success || !result.images || result.images.length === 0) {
        throw new Error("No images generated by NANO BANANA");
      }

      const generatedImage = result.images[0];
      
      // Return static video placeholder - actual video creation handled by processors
      const tempId = cuid();
      const dimensions = params.orientation === OrientationEnum.portrait 
        ? VIDEO_DIMENSIONS.PORTRAIT 
        : VIDEO_DIMENSIONS.LANDSCAPE;
      
      const [width, height] = dimensions.split('x').map(Number);

      return {
        url: `nano-banana://${tempId}`, // Special URL to indicate NANO BANANA source
        width,
        height,
        id: tempId
      };
      
    } catch (error) {
      logger.error(error, "Failed to generate static video with NANO BANANA");
      throw new Error(`NANO BANANA video generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async generateMultipleImages(
    params: NanoBananaVideoParams,
    numberOfImages: number = 4
  ): Promise<Array<{ data: string; mimeType: string }>> {
    try {
      logger.debug({ 
        prompt: params.imageData.prompt, 
        numberOfImages 
      }, "Generating multiple images with NANO BANANA for consistency");

      const enhancedPrompt = `${params.imageData.prompt}. Style: ${params.imageData.style}. Mood: ${params.imageData.mood}`;
      const aspectRatio = params.orientation === OrientationEnum.portrait ? "9:16" : "16:9";
      
      const result = await this.imageGenerationService.generateImages({
        prompt: enhancedPrompt,
        numberOfImages: numberOfImages,
        aspectRatio: aspectRatio
      }, params.videoId);

      if (!result.success || !result.images || result.images.length === 0) {
        throw new Error("No images generated by NANO BANANA");
      }

      return result.images.map(img => ({
        data: img.data.toString('base64'),
        mimeType: img.mimeType || 'image/png'
      }));
      
    } catch (error) {
      logger.error(error, "Failed to generate multiple images with NANO BANANA");
      throw error;
    }
  }
}